/* Atividade: Um jogo de adivinhar um número gerado automaticamente pelo código.
O programa deve informar e permitir que o jogador insira números;
O programa deve gerar um número aleatório entre 1 a 1000;
O programa deve informar ao jogador se o número inserido por ele está abaixo, acima ou é igual o número aleatório;
O programa deve sair automaticamente quando o jogador adivinhar o número ou quando ele inserir qualquer valor que não seja um número. */

/*
    Activity: A game of guessing a number randomly generated by code.
    The software should print and allow the user to enter numbers;
    The software should generate a number randomly between 1 and 1000;
    The software should print to player whether the number inserted is lower, higher or equal than the random number;
    THe software should exit when the player guesses the number or when they enter any value other than the number.
*/
use rand::Rng;
use std::cmp::Ordering;
use std::io::{self, BufRead, BufReader, BufWriter, Write};
use std::num::ParseIntError;
/// This program generates a random number between 1 and 1000 and asks the user to guess it.
/// The user inputs their guess and the program tells them if their guess is too high or too low.
/// The program continues to prompt the user for guesses until they correctly guess the number.
fn main() {
    println!("Adivinha um número");
    let secret = rand::thread_rng().gen_range(1, 1001);

    loop {
        println!("Por favor, Digite seu palpite de um número");
        let mut buf_read = BufReader::new(io::stdin());
        let guess = match match_number(&mut buf_read) {
            Ok(num) => num,
            Err(_) => continue,
        };
        let mut buf_writer = BufWriter::new(io::stdout());
        println!("O número inserido é: {}", guess);
        let _ = print_result(&mut buf_writer, &secret, &guess);
    }
}

fn match_number<T: BufRead>(read: &mut T) -> Result<u32, ParseIntError> {
    let mut guess = String::new();
    read.read_line(&mut guess)
        .expect("Falha ao ler a linha de comando");

    guess.trim().parse::<u32>()
}

fn print_result<T: Write>(output: &mut T, secret: &u32, guess: &u32) -> Result<(), std::io::Error> {
    match guess.cmp(&secret) {
        Ordering::Equal => {
            write!(output, "Você ganhou!\n")
        }
        Ordering::Less => write!(output, "Muito abaixo\n"),
        Ordering::Greater => write!(output, "Muito acima\n"),
    }
}

#[cfg(test)]
mod test {
    use std::{num::IntErrorKind, str};

    use crate::{match_number, print_result};

    #[test]
    fn shoud_match_number() {
        let buf = "32";

        let r = match_number(&mut buf.as_ref());

        assert_eq!(Ok(32), r)
    }

    #[test]
    fn shoud_match_number_not() {
        let buf = "teste";

        let r = match_number(&mut buf.as_ref());

        assert_eq!(r.err().unwrap().kind(), &IntErrorKind::InvalidDigit)
    }

    #[test]
    fn shoud_print_result() {
        let mut binding = vec![];

        let r = print_result(&mut binding, &32, &32);
        dbg!(str::from_utf8(&binding).unwrap());
        assert!(r.is_ok())
    }
}
