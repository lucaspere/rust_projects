///! A game of guessing a number randomly generated by code.
///! The software should print and allow the user to enter numbers;
///! The software should generate a number randomly between 1 and 1000;
///! The software should print to player whether the number inserted is lower, higher or equal than the random number;
///! The software should exit when the player guesses the number or when they enter any value other than the number.
use std::{
    cmp::Ordering,
    io::{stdin, BufRead, BufReader, Error, Write},
};

pub struct Config {
    secret: u32,
}

impl Config {
    pub fn new(secret: u32) -> Self {
        Self { secret }
    }
    pub fn run(&self) -> Result<(), Error> {
        loop {
            println!("Please, enter a guess number");
            let mut buf_read = BufReader::new(stdin());

            let guess = Config::match_number(&mut buf_read)?;
            let mut buf_write = Vec::new();
            self.print_result(&mut buf_write, &guess)?;

            if let Ok(result) = String::from_utf8(buf_write) {
                println!("{result}");
                if result == "You win ðŸŽ‰!".to_string() {
                    break Ok(());
                }
            }
        }
    }
    fn match_number<T: BufRead>(read: &mut T) -> Result<u32, Error> {
        let mut guess = String::new();
        read.read_line(&mut guess)?;

        guess
            .trim()
            .parse::<u32>()
            .map_err(|err| Error::new(std::io::ErrorKind::Other, err))
    }

    fn print_result<T: Write>(&self, output: &mut T, guess: &u32) -> Result<(), Error> {
        match guess.cmp(&self.secret) {
            Ordering::Equal => {
                write!(output, "You win ðŸŽ‰!")
            }
            Ordering::Less => write!(output, "Guess is lower"),

            Ordering::Greater => write!(output, "Guess is higher"),
        }
    }
}

#[cfg(test)]
mod test {
    use std::{
        io::{Error, ErrorKind},
        num::IntErrorKind,
        str,
    };

    use crate::Config;

    #[test]
    fn shoud_match_number() {
        let buf = "32";

        let r = Config::match_number(&mut buf.as_ref()).expect("should parser a valid u32 number");
        assert_eq!(32, r)
    }

    #[test]
    fn shoud_match_number_not() {
        let buf = "teste";

        let r = Config::match_number(&mut buf.as_ref());

        assert_eq!(r.err().unwrap().kind(), ErrorKind::Other)
    }

    #[test]
    fn shoud_print_result() {
        let config = Config::new(10);
        let mut binding = vec![];

        let r = config.print_result(&mut binding, &32);
        assert!(r.is_ok())
    }
}
