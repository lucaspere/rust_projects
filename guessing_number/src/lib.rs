///! A game of guessing a number randomly generated by code.
///! The software should print and allow the user to enter numbers;
///! The software should generate a number randomly between 1 and 1000;
///! The software should print to player whether the number inserted is lower, higher or equal than the random number;
///! The software should exit when the player guesses the number or when they enter any value other than the number.
use std::{
    cmp::Ordering,
    io::{stdin, stdout, BufRead, BufReader, Error, Write},
};

pub struct Config {
    secret: u32,
    reader: Option<Box<dyn BufRead>>,
    writer: Option<Box<dyn Write>>,
}

impl Config {
    pub fn new(
        secret: u32,
        reader: Option<Box<dyn BufRead>>,
        writer: Option<Box<dyn Write>>,
    ) -> Self {
        let reader = reader.or_else(|| Some(Box::new(BufReader::new(stdin()))));
        let writer = writer.or_else(|| Some(Box::new(stdout())));
        Self {
            secret,
            reader,
            writer,
        }
    }

    pub fn run(&mut self) -> Result<(), Error> {
        loop {
            println!("Please, enter a guess number");
            let mut buf_reader = self.reader.as_mut().unwrap();
            let guess = Config::match_number(&mut buf_reader)?;
            let mut buf_write = self.writer.as_mut().unwrap();
            if Config::print_result(&self.secret, &mut buf_write, &guess)? {
                break Ok(());
            }
        }
    }
    fn match_number<T: BufRead>(read: &mut T) -> Result<u32, Error> {
        let mut guess = String::new();
        read.read_line(&mut guess)?;

        guess
            .trim()
            .parse::<u32>()
            .map_err(|err| Error::new(std::io::ErrorKind::Other, err))
    }

    fn print_result<T: Write>(secret: &u32, output: &mut T, guess: &u32) -> Result<bool, Error> {
        match guess.cmp(&secret) {
            Ordering::Equal => {
                write!(output, "You win üéâ!\n")?;
                Ok(true)
            }
            Ordering::Less => {
                write!(output, "Guess number is lower üëáüèΩ\n")?;
                Ok(false)
            }

            Ordering::Greater => {
                write!(output, "Guess number is higher ‚òùüèΩ\n")?;
                Ok(false)
            }
        }
    }
}

#[cfg(test)]
mod test {
    use std::io::ErrorKind;

    use crate::Config;

    #[test]
    fn shoud_match_number() {
        let buf = "32";

        let r = Config::match_number(&mut buf.as_ref()).expect("should parser a valid u32 number");
        assert_eq!(32, r)
    }

    #[test]
    fn shoud_match_number_not() {
        let buf = "teste";

        let r = Config::match_number(&mut buf.as_ref());

        assert_eq!(r.err().unwrap().kind(), ErrorKind::Other)
    }

    #[test]
    fn shoud_print_result() {
        let config = Config::new(10, None, None);
        let mut binding = vec![];

        let r = Config::print_result(&config.secret, &mut binding, &32);
        assert!(r.is_ok())
    }
}
